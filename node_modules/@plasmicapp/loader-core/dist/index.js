"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Api: () => import_loader_fetcher.Api,
  PlasmicModulesFetcher: () => import_loader_fetcher.PlasmicModulesFetcher,
  PlasmicTracker: () => PlasmicTracker,
  Registry: () => Registry,
  getBundleSubset: () => getBundleSubset
});
module.exports = __toCommonJS(src_exports);
var import_loader_fetcher = require("@plasmicapp/loader-fetcher");

// src/deps-graph.ts
var DepsGraph = class {
  constructor(bundle, browserBuild) {
    this.bundle = bundle;
    this.browserBuild = browserBuild;
    this.dependsOn = {};
    this.dependedBy = {};
    this.rebuildGraph();
  }
  getTransitiveDependers(name2) {
    return this.transitiveCrawl(name2, this.dependedBy);
  }
  getTransitiveDeps(name2) {
    if (!(name2 in this.dependsOn)) {
      return [];
    }
    return this.transitiveCrawl(name2, this.dependsOn);
  }
  transitiveCrawl(name2, edges) {
    const deps = /* @__PURE__ */ new Set();
    const crawl = (dep2) => {
      var _a;
      if (deps.has(dep2)) {
        return;
      }
      deps.add(dep2);
      for (const subdep of (_a = edges[dep2]) != null ? _a : []) {
        crawl(subdep);
      }
    };
    for (const dep2 of edges[name2]) {
      crawl(dep2);
    }
    return Array.from(deps);
  }
  rebuildGraph() {
    this.dependedBy = {};
    this.dependsOn = {};
    for (const mod of this.browserBuild ? this.bundle.modules.browser : this.bundle.modules.server) {
      if (mod.type === "code") {
        for (const imported of mod.imports) {
          if (!(mod.fileName in this.dependsOn)) {
            this.dependsOn[mod.fileName] = [imported];
          } else {
            this.dependsOn[mod.fileName].push(imported);
          }
          if (!(imported in this.dependedBy)) {
            this.dependedBy[imported] = [mod.fileName];
          } else {
            this.dependedBy[imported].push(mod.fileName);
          }
        }
      }
    }
  }
};

// src/bundles.ts
function getBundleSubset(bundle, names, opts2) {
  var _a, _b;
  const namesSet = new Set(names);
  const target = (_a = opts2 == null ? void 0 : opts2.target) != null ? _a : "browser";
  const forBrowser = target === "browser";
  const graph = new DepsGraph(bundle, forBrowser);
  const deps = new Set(names.flatMap((name2) => graph.getTransitiveDeps(name2)));
  const isSubModule = (fileName) => deps.has(fileName) || namesSet.has(fileName);
  const modules = bundle.modules[target];
  const filteredModules = modules.filter((mod) => isSubModule(mod.fileName));
  const filteredComponents = bundle.components.filter(
    (c) => isSubModule(c.entry)
  );
  const filteredComponentsIds = new Set(filteredComponents.map((c) => c.id));
  const filteredIds = Object.fromEntries(
    Object.entries(bundle.filteredIds).map(([k, v]) => [k, [...v]])
  );
  bundle.components.filter((c) => !filteredComponentsIds.has(c.id)).forEach((component) => {
    var _a2;
    filteredIds[component.projectId] = (_a2 = filteredIds[component.projectId]) != null ? _a2 : [];
    if (!filteredIds[component.projectId].includes(component.id)) {
      filteredIds[component.projectId].push(component.id);
    }
  });
  return {
    modules: {
      browser: forBrowser ? filteredModules : [],
      server: forBrowser ? [] : filteredModules
    },
    components: filteredComponents,
    globalGroups: bundle.globalGroups,
    projects: bundle.projects,
    activeSplits: bundle.activeSplits,
    bundleKey: (_b = bundle.bundleKey) != null ? _b : null,
    deferChunksByDefault: bundle.deferChunksByDefault,
    disableRootLoadingBoundaryByDefault: bundle.disableRootLoadingBoundaryByDefault,
    filteredIds
  };
}

// src/registry.ts
var isBrowser = typeof window !== "undefined" && window != null && typeof window.document !== "undefined";
function isModuleBundlePromiseSet(name2) {
  return globalThis.__PlasmicBundlePromises && !!globalThis.__PlasmicBundlePromises[name2] && !!globalThis.__PlasmicBundlePromises[name2].then;
}
var Registry = class {
  constructor() {
    this.loadedModules = {};
    this.registeredModules = {};
    this.modules = {};
  }
  register(name2, module2) {
    this.registeredModules[name2] = module2;
  }
  isEmpty() {
    return Object.keys(this.loadedModules).length === 0;
  }
  clear() {
    this.loadedModules = {};
  }
  getRegisteredModule(name2) {
    return this.registeredModules[name2];
  }
  hasModule(name2, opts2 = {}) {
    if (name2 in this.registeredModules && !opts2.forceOriginal) {
      return true;
    }
    if (name2 in this.modules) {
      return true;
    }
    if (globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name2]) {
      return true;
    }
    if (isModuleBundlePromiseSet(name2)) {
      return true;
    }
    return false;
  }
  load(name, opts = {}) {
    if (name in this.registeredModules && !opts.forceOriginal) {
      return this.registeredModules[name];
    }
    if (name in this.loadedModules) {
      return this.loadedModules[name];
    }
    if (!this.modules[name] && globalThis.__PLASMIC_CHUNKS && !!globalThis.__PLASMIC_CHUNKS[name]) {
      this.modules[name] = globalThis.__PLASMIC_CHUNKS[name];
    }
    if (!this.modules[name] && isModuleBundlePromiseSet(name)) {
      throw globalThis.__PlasmicBundlePromises[name];
    }
    if (!(name in this.modules)) {
      throw new Error(`Unknown module ${name}`);
    }
    const code = this.modules[name];
    const requireFn = isBrowser ? (dep2) => {
      const normalizedDep = resolvePath(dep2, name);
      return this.load(normalizedDep);
    } : (dep) => {
      try {
        const normalizedDep = resolvePath(dep, name);
        return this.load(normalizedDep);
      } catch (err) {
        try {
          return eval("require")(dep);
        } catch (e) {
          throw err;
        }
      }
    };
    let func;
    try {
      func = new Function("require", "exports", code);
    } catch (err2) {
      throw new Error(`PLASMIC: Failed to create function for ${name}: ${err2}`);
    }
    const exports = {};
    this.loadedModules[name] = exports;
    try {
      func(requireFn, exports);
    } catch (err2) {
      delete this.loadedModules[name];
      if (!(err2 instanceof Error) && !!err2 && !!err2.then) {
        throw err2;
      }
      throw new Error(`PLASMIC: Failed to load ${name}: ${err2}`);
    }
    return exports;
  }
  updateModules(bundle) {
    let updated = false;
    for (const mod of isBrowser ? bundle.modules.browser : bundle.modules.server) {
      if (mod.type === "code" && !!mod.code && mod.code !== this.modules[mod.fileName]) {
        this.modules[mod.fileName] = mod.code;
        if (!globalThis.__PLASMIC_CHUNKS) {
          globalThis.__PLASMIC_CHUNKS = {};
        }
        globalThis.__PLASMIC_CHUNKS[mod.fileName] = mod.code;
        updated = true;
      }
    }
    if (updated) {
      this.clear();
    }
  }
};
function resolvePath(path, from) {
  const fromParts = from.split("/");
  const pathParts = path.split("/");
  if (pathParts.length === 0) {
    return path;
  }
  if (pathParts[0] === ".") {
    return [
      ...fromParts.slice(0, fromParts.length - 1),
      ...pathParts.slice(1)
    ].join("/");
  } else if (pathParts[0] === "..") {
    let count = 0;
    for (const part of pathParts) {
      if (part === "..") {
        count += 1;
      } else {
        break;
      }
    }
    return [
      ...fromParts.slice(0, fromParts.length - count - 1),
      ...pathParts.slice(count)
    ].join("/");
  } else {
    return path;
  }
}

// src/tracker/index.ts
var PlasmicTracker = class {
  // Preserve constructor signature for compatibility, but do not retain
  // instance state to avoid unused-property diagnostics.
  constructor(_opts) {
  }
  /**
   * @deprecated No-op.
   */
  trackRender(_opts) {
  }
  /**
   * @deprecated No-op.
   */
  trackFetch() {
  }
  /**
   * @deprecated No-op.
   */
  trackConversion(_value = 0) {
  }
};
//# sourceMappingURL=index.js.map
